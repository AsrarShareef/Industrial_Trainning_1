# Industrial_Trainning_Introduction
My self Mohammed Asrar Uddin Shareef, I am doing this as a part of my Diploma course that is Industrial Trainning in 3rd Year 6th Semester.

So during this course we have learned about the following:-
        
        CHAPTER-1
Introduction to IC Design
 Key Concepts:-
1.1 WHAT IS IC DESIGN?                                                            
1.2 TYPES ICs                                                                              
1.3 TOOLS REQUIRED FOR IC DESIGN                                      
1.4 WHAT IS PDKs?

1.1 WHAT IS IC DESIGN? 
                      The goal of circuit design is to assemble a collection of interconnected circuit elements that perform a specific objective function. The ability to add or multiply numbers is a simple example. The development of a microprocessor that executes computer instructions to perform complex tasks is another example.The circuit elements used in this process begin with fundamental building blocks such as transistors, resistors, capacitors, and wires. These elements are combined to form more complex functions such as logic gates or precision amplifiers, which are then combined to form more complex functions such as adders and multipliers. This process continues to build on itself, resulting in the availability of increasingly complex circuit building blocks.
                      1.2 TYPES ICs:-
                      Every electronic appliance we use in our day-to-day life, such as mobile phones, laptops, refrigerators, computers, televisions, and all other electrical and electronic devices are manufactured with some simple or complex circuits.
                     Different Types of ICS:-
Based on the intended application, the IC is classified as analog integrated circuits, digital integrated circuits, and mixed integrated circuits:-
1.Digital Integrated Circuits:-
The integrated circuits that operate only at a few defined levels instead of operating overall levels of signal amplitude are called Digital ICs and these are designed by using multiple numbers of digital logic gates, multiplexers, flip flops, and other electronic components of circuits. These logic gates work with binary input data or digital input data, such as 0 (low or false or logic 0) and 1 (high or true or logic 1).
2.Analog Integrated Circuits:-
The integrated circuits that operate over a continuous range of signals are called Analog ICs. These are subdivided into linear Integrated Circuits (Linear ICs) and Radio Frequency Integrated Circuits (RF ICs). In fact, the relationship between the voltage and current may be nonlinear in some cases over a long range of the continuous analog signal.
3.Mixed Integrated Circuits:-
The integrated circuits that are obtained by the combination of analog and digital ICs on a single chip are called Mixed ICs. These ICs functions as Digital to Analog converters, Analog to Digital converters (D/A and A/D converters), and clock/timing ICs. The circuit depicted in the above figure is an example of the mixed integrated circuit which is a photograph of the 8 to 18 GHz self-healing radar receiver.
4.Logic Circuits:-
These ICs are designed using logic gates-that work with binary input and output (0 or 1). These are mostly used as decision-makers. Based on the logic or truth table of the logic gates, all the logic gates connected in the IC give an output based on the circuit connected inside the IC- such that this output is used for performing a specific intended task. 
5.Comparators:-
The comparator ICs are used as comparators for comparing the inputs and then to produce an output based on the ICs’ comparison.
6.Switching ICs:-
Switches or Switching ICs are designed by using the transistors and are used for performing the switching operations. The above figure is an example showing an SPDT IC switch.
7.Switching ICs
Audio Amplifiers:-
The audio amplifiers are one of the many types of ICs, which are used for the amplification of the audio. These are generally used in audio speakers, television circuits, and so on. The above circuit shows the low- voltage audio amplifier IC.
 1.Audio amplifiers
CMOS Integrated Circuit:-
CMOS integrated circuits are extremely used in different applications as compared with FETs because of their capabilities like lower threshold voltage, low-power consumption. A CMOS IC includes P-MOS & N-MOS devices which are fabricated jointly on a similar chip. The structure of this IC is a Polysilicon gate that aids to decrease the device’s threshold voltage, therefore allowing process at low-voltage levels.
2..Voltage Regulator ICs:-
This kind of integrated circuit provides a stable DC output despite the changes within DC input. The commonly used type regulators are LM309, uA723, LM105 & 78XX ICs.
3.perational Amplifiers:-
The operational amplifiers are frequently used ICs, similar to the audio amplifiers which are used for the audio amplification. These op-amps are used for amplification purposes, and these ICs work similarly to the transistor amplifier circuits. The pin configuration of the 741 op-amp IC is shown in the below figure..
 
8.Timer ICs:-
Timers are special-purpose integrated circuits used for the purpose of counting and to keep a track of time in intended applications. The block diagram of the internal circuit of the LM555 timer IC is shown in the above circuit. Based on the number of components used (typically based on the number of transistors used), they are as follows
 
9.Timer ICs
1.Small-scale Integration consists of only a few transistors (tens of transistors on a chip), these ICs played a critical role in early aerospace projects.
2.Medium-scale Integration consists of some hundreds of transistors on the IC chip developed in the 1960s and achieved better economy and advantages compared to the SSI ICs.
3.Large-scale Integration consists of thousands of transistors on the chip with almost the same economy as medium-scale integration ICs. The first microprocessor, calculator chips, and RAMs of 1Kbit developed in the 1970s  had below four thousand transistors.
4.Very Large-scale Integration consists of transistors from hundreds to several billion in number.(Development period: from the 1980s to 2009)

****Types of Integrated Circuits based on Classes:-
Integrated circuits are available in three classes based on the techniques used while manufacturing them:-
•	Thin and thick film ICs.
•	Monolithic ICs.
•	Hybrid or multichip ICs.

1.3 TOOLS REQUIRED FOR IC DESIGN:-
      EDA Tools:-
EnSilica is experienced in using a wide range of best in class EDA tools to improve the quality and efficiency of IC design, verification and test.  The EDA tools we typically use in both our Custom ASIC Design and full-flow IC/ASIC Design Services include:
•	Design Control	SVN and ClioSoft
•	Document Control	Cognidox
•	Requirements Capture	Sparx Systems Enterprise Architect
•	Regression	Jenkins/ Cadence vManager
•	System Design	Mathworks Matlab / GNU Octave, Excel, Verilog
•	Analog Environment	Cadence Virtuoso IC (Composer, ADE-XL, LayoutXL)
•	RF/Analog/MS Simulation	Cadence Spectre/ MMSIM, Mentor AFS/Symphony, Keysight ADS
•	Electro-Magnetic simulation	Keysight RFpro, Momentum & FEM, Ansys HFSS
•	Digital Simulation	Mentor Questa, Cadence Xcelium Simulator
•	Verification planning	Excel / Cadence vManager
•	Linting / CDC	Questa CDC, Cadence HAL
•	Synthesis	Synopsys Design Compler Ultra & Cadence Genus Synthesis Solution
•	UPF Verification	Synopsys Verdi Suite
•	Place & Route	Cadence Innovus and Synopsys IC Compiler II
•	DFT	Mentor Tessent
•	Layout Extraction	Mentor Calibre PEX (analog), Synopsys StarRC (digital)
•	Digital Sign-off Timing	Synopsys PrimeTime
•	Power/Thermal Analysis	Cadence Voltus
•	Logic Equivalence	Synopsys Formality and Cadence Conformal
•	Physcial Verification	Mentor Calibre DRC/ERC/LVS
•	PCB Design and layout	Altium Designer
•	Yield Analysis	YieldHUB
                                     
                               
1.4 WHAT IS PDKs ?
  Process design kit
A process design kit (PDK) is a set of files used within the semiconductor industry to model a fabrication process for the design tools used to design an integrated circuit. The PDK is created by the foundry defining a certain technology variation for their processes. It is then passed to their customers to use in the design process. The customers may enhance the PDK, tailoring it to their specific design styles and markets. The designers use the PDK to design, simulate, draw and verify the design before handing the design back to the foundry to produce chips. The data in the PDK is specific to the foundry's process variation and is chosen early in the design process, influenced by the market requirements for the chip. An accurate PDK will increase the chances of first-pass successful silicon.
     Different tools in the design flow have different input formats for the PDK data. The PDK engineers have to decide which tools they will support in the design flows and create the libraries and rule sets which support those flows.
A typical PDK contains:
•	A primitive device library
o	Symbols
o	Device parameters
o	PCells
•	Verification decks
o	Design Rule Checking
o	Layout Versus Schematic
o	Antenna and Electrical rule check
o	Physical Extraction
•	Technology data
o	Layers, layer names, layer/purpose pairs
o	Colors, fills and display attributes
o	Process constraints
o	Electrical rules
•	Rule files
o	LEF
o	Tool dependent rule formats
•	Simulation models of primitive devices (SPICE or SPICE derivatives)
o	Transistors (typically SPICE)
o	Capacitors
o	Resistors
o	Inductors
•	Design Rule Manual
o	A user friendly representation of the process requirements
A PDK may also include standard cell libraries from the foundry, a library vendor or developed internally
•	LEF format of abstracted layout data
•	Symbols
•	Library (.lib) files
•	GDSII layout data

CONCLUSION: From this chapter we have learnt about the Ics,Different types of Ics, different types of Ics based on design and about tools required for Ic design and what are PDKs and difreeent PDKs.
______________________________________________________________________________________________________________________________________________________________________________
CHAPTER-2 - 
2.1 WHAT IS HDL?                                                                                    
2.2 INTRODUCTION TO VERILOG HDL                                                 
2.2.1 DATA TYPES
2.2.2 TYPES OF MODELING 
2.3 DIGITAL IC DESIGN FLOW                                                             
2.4 WHAT IS MEANT BY SIMULATION?                                             
2.5  WHAT IS MEANT BY SYNTHESIS?                                                 
 2.6 CONCLUSION       
 
 2.1 WHAT IS HDL?         
       A Hardware Description Language (HDL) is a specialized computer language used to describe the structure and behavior of electronic circuits, and most commonly, digital logic circuits.
A hardware description language enables a precise, formal description of an electronic circuit that allows for the automated analysis and simulation of an electronic circuit. It also allows for the synthesis of an HDL description into a netlist (a specification of physical electronic components and how they are connected together), which can then be placed and routed to produce the set of masks used to create an integrated circuit.

2.2 INTRODUCTION TO VERILOG HDL :-     
Verilog HDL is one of the two most common Hardware Description Languages (HDL) used by integrated circuit (IC) designers. The other one is VHDL. 
Verilog can be used to describe designs at four levels of abstraction: 
(i) Algorithmic level (much like c code with if, case and loop statements). 
(ii) Register transfer level (RTL uses registers connected by Boolean equations). 
(iii) Gate level (interconnected AND, NOR etc.).
 (iv) Switch level (the switches are MOS transistors inside gates). The language also defines constructs that can be used to control the input and output of simulation. 
There are two types of code in most HDLs:
 1.Structural, which is a verbal wiring diagram without storage. assign a=b & c | d; /* “|” is a OR */ assign d = e & (~c); Here the order of the statements does not matter. Changing e will change a. 
2.Procedural which is used for circuits with storage, or as a convenient way to write conditional logic. always @(posedge clk) // Execute the next statement on every rising clock edge. count <= count+1; 
Procedural code is written like c code and assumes every assignment is stored in memory until over written. For synthesis, with flip-flop storage, this type of thinking generates too much storage. However people prefer procedural code because it is usually much easier to write, for example, if and case statements are only allowed in procedural code. As a result, the synthesizers have been constructed which can recognize certain styles of procedural code as actually combinational. They generate a flip-flop only for left-hand variables which truly need to be stored. However if you stray from this style, beware. Your synthesis will start to fill with superfluous latches.

2.2.1 DATA TYPES:-
Value Set:-
 Verilog consists of only four basic values. Almost all Verilog data types store all these values: 
0 (logic zero, or false condition)
 1 (logic one, or true condition) 
x (unknown logic value) x and z have limited use for synthesis.
 z (high impedance state)
 
Wire:-
 A wire represents a physical wire in a circuit and is used to connect gates or modules. The value of a wire can be read, but not assigned to, in a function or block. See “Functions” on p. 19, and “Procedures: Always and Initial Blocks” on p. 18. A wire does not store its value but must be driven by a continuous assignment statement or by connecting it to the output of a gate or module. Other specific types of wires include:
 wand (wired-AND);:the value of a wand depend on logical AND of all the drivers connected to it.
 wor (wired-OR);: the value of a wor depend on logical OR of all the drivers connected to it. 
tri (three-state;): all drivers connected to a tri must be z, except one (which determines the value of the tri).
Syntax :-
wire [msb:lsb] wire_variable_list; 
wand [msb:lsb] wand_variable_list;
 wor [msb:lsb] wor_variable_list; 
tri [msb:lsb] tri_variable_list; 
Example :-
wire c // simple wire wand d;
 assign d = a; // value of d is the logical AND of 
assign d = b; // a and b 
wire [9:0] A; // a cable (vector) of 10 wires

Reg:-
Declare type reg for all data objects on the left hand side of expressions in inital and always procedures, or functions. See “Procedural Assignments”. A reg is the data type that must be used for latches, flip-flops and memorys. However it often synthesizes into leads rather than storage. In multi-bit registers, data is stored as unsigned numbers and no sign extension is done for what the user might have thought were two’s complement numbers..
Syntax :-
reg [msb:lsb] reg_variable_list; 
Example :-
reg a; // single 1-bit register variable 
reg [7:0] tom; // an 8-bit vector; a bank of 8 registers.
 reg [5:0] b, c; // two 6-bit variables

Input, Output, Inout :-
These keywords declare input, output and bidirectional ports of a module or task. Input and inout ports are of type wire. An output port can be configured to be of type wire, reg, wand, wor or tri. The default is wire.
Syntax :-
input [msb:lsb] input_port_list;
 output [msb:lsb] output_port_list;
 inout [msb:lsb] inout_port_list; 
Example:- 
 module sample(b, e, c, a); //See “Module Instantiations” on p. 10 
input a; // An input which defaults to wire. 
output b, e; // Two outputs which default to wire 
output [1:0] c; /* A two-it output. One must declare its type in a separate statement. */ 
reg [1:0] c; // The above c port is declared as reg.

Integer:-
 Integers are general-purpose variables. For synthesois they are used mainly loops-indicies, parameters, and constants. See“Parameter” on p. 5. They are of implicitly of type reg. However they store data as signed numbers whereas explicitly declared reg types store them as unsigned. If they hold numbers which are not defined at compile time, their size will default to 32-bits. If they hold constants, the synthesizer adjusts them to the minimum width needed at compilation.
Syntax:-
 integer integer_variable_list; ... integer_constant ... ;
Example:-
 integer a; // single 32-bit integer
 assign b=63; // 63 defaults to a 7-bit variable
 
Supply0, Supply1:-
 Supply0 and supply1 define wires tied to logic 0 (ground) and logic 1 (power), respectively
Syntax :-
supply0 logic_0_wires; 
supply1 logic_1_wires;
Example:-
supply0 my_gnd; // equivalent to a wire assigned 0 
supply1 a, b;

Time:-
 Time is a 64-bit quantity that can be used in conjunction with the $time system task to hold simulation time. Time is not supported for synthesis and hence is used only for simulation purposes.
Syntax :-
time time_variable_list
Example :-
time c; c = $time;
 // c = current simulation time
 
Parameters :-
Parameters allows constants like word length to be defined symbolically in one place. This makes it easy to change the word length later, by change only the parameter. See also “Parameterized Modules” . An alternative way to do the same thing is to use macro substitution, see “Macro Definitions
Syntax:-
 parameter par_1 = value, 
par_2 = value, .....; 
parameter [range] parm_3 = value
Example :-
 parameter add = 2’b00, sub = 3’b111;
 parameter n = 4; 
parameter [3:0] st4 = 4’b1010; ... 
reg [n-1:0] harry; /* A 4-bit register whose length is set by parameter n above. */ 
always @(x)
 y = {{(add - sub){x}}; // The replication operator Sect. 5.8.
 if (x) begin 
state = st4[1]; else state = st4[2]; 
end


2.2.2 TYPES OF MODELING :-
Verilog HDL modeling language supports three kinds of modeling styles: gate-level, dataflow, and behavioral. The gate-level and datafow modeling are used to model combinatorial circuits whereas the behavioral modeling is used for both combinatorial and sequential circuits.
1. Gate-level Modeling :-
 Verilog HDL supports built-in primitive gates modeling. The gates supported are multiple-input, multipleoutput, tristate, and pull gates. The multiple-input gates supported are: and, nand, or, nor, xor, and xnor whose number of inputs are two or more, and has only one output. The multiple-output gates supported are buf and not whose number of output is one or more, and has only one input. The language also supports modeling of tri-state gates which include bufif0, bufif1, notif0, and notif1. These gates have one input, one control signal, and one output. The pull gates supported are pullup and pulldown with a single output (no input) only. The basic syntax for each type of gates with zero delays is as follows: and | nand | or | nor | xor | xnor [instance name] (out, in1, …, inN); // [] is optional and | is selection buf | not [instance name] (out1, out2, …, out2, input); bufif0 | bufif1 | notif0 | notif1 [instance name] (outputA, inputB, controlC); pullup | pulldown [instance name] (output A); One can also have multiple instances of the same type of gate in one construct separated by a comma such as and [inst1] (out11, in11, in12), [inst2] (out21, in21, in22, in23), [inst3] (out31, in31, in32, in33); The language also allows the delays to be expressed when instantiating gates. The delay expressed is from input to output. The delays can be expressed in form of rise, fall, and turn-off delays; one, two, or all three types of delays can be expressed in a given instance expression. The turn-off delay is applicable to gates whose output can be turned OFF(.e.g. notif1). For example, and #5 A1(Out, in1, in2); // the rise and fall delays are 5 units and #(2,5) A2(out2, in1, in2); // the rise delay is 2 unit and the fall delay is 5 units notif1 #(2, 5, 4) A3(out3, in2, ctrl1); //the rise delay is 2, the fall delay is 5, and the turnoff delay is 4 unit The gate-level modeling is useful when a circuit is a simple combinational, as an example a multiplexer. Multiplexer is a simple circuit which connects one of many inputs to an output. In this part, you will create a simple 2-to-1 multiplexer and extend the design to multiple bits.
 
 2. Dataflow Modeling:-
Dataflow modeling style is mainly used to describe combinational circuits. The basic mechanism used is the continuous assignment. In a continuous assignment, a value is assigned to a data type called net.
 The syntax of a continuous assignment is assign [delay] LHS_net = RHS_expression;
 Where LHS_net is a destination net of one or more bit, and RHS_expression is an expression consisting of various operators. The statement is evaluated at any time any of the source operand value changes and the result is assigned to the destination net after the delay unit. The gate level modeling examples listed in Part 1 can be described in dataflow modeling using the continuous assignment.
 For example, assign out1 = in1 & in2; // perform and function on in1 and in2 and assign the result to out1
 assign out2 = not in1;
 assign #2 z[0] = ~(ABAR & BBAR & EN); // perform the desired function and assign the result after 2 units The target in the continuous assignment expression can be one of the following: 
1. A scalar net (e.g. 1st and 2nd examples above)
 2. Vector net 
3. Constant bit-select of a vector (e.g. 3rd example above)
 4. Constant part-select of a vector 
5. Concatenation of any of the above Let us take another set of examples in which a scalar and vector nets are declared and used 
wire COUNT, CIN; // scalar net declaration
 wire [3:0] SUM, A, B; // vector nets declaration 
assign {COUT,SUM} = A + B + CIN; // A and B vectors are added with CIN and the result is // assigned to a concatenated vector of a scalar and vector nets.
Note that multiple continuous assignment statements are not allowed on the same destination net.

3Behavioral Modeling:-
Behavioral modeling is used to describe complex circuits. It is primarily used to model sequential circuits,
but can also be used to model pure combinatorial circuits. The mechanisms (statements) for modeling the
behavior of a design are:
initial Statements
always Statements.

2.3 DIGITAL IC DESIGN FLOW :-
Today, IC design flow is a very solid and mature process. The overall IC design flow and the various steps within the IC design flow have proven to be both practical and robust in multi-millions IC designs until now.IC design flow is not exactly a push button process. To succeed in the IC design flow process, one must have: a robust and silicon-proven flow, a good understanding of the IC specifications and constraints, and an absolute domination over the required EDA tools (and their reports!).

2.4 WHAT IS MEANT BY SIMULATION?  
Simulation Defined as:-	
•	Simulation refers to modeling of a design, its function and performance.
•	A software simulator is a computer program; an emulator is a hardware simulator.
•	Simulation is used for design verification:
•	Validate assumptions
•	Verify logic
•	Verify performance (timing)
Types of simulation:
•	Logic or switch level
•	Timing
•	Circuit
•	Fault 
Simulators are usually divided into the following categories or simulation modes :
•	Behavioral simulation
•	Functional simulation
•	Static timing analysis
•	Gate-level simulation
•	Switch-level simulation
•	Transistor-level or circuit-level simulation

2.5  WHAT IS MEANT BY SYNTHESIS?
Synthesis is the process of transforming your HDL design into a gate-level netlist, given all the specified constraints and optimization settings.
Logic synthesis is the process of translating and mapping RTL code written in HDL (such as Verilog or VHDL ) into technology specific gate  level representation.
 
There are 3 steps in Synthesis:
  Translation: RTL code is translated to technolohgy independent representation. The converted logic is available in boolean equation form.
  Optimization: Boolean equation is optimized using SoP or PoS optimization methods.
  Technology mapping:  Technology independent boolean logic equations are mapped to technology dependant library logic gates based on design constraints, library of available technology gates.  This produces optimized gate level representation which is generally represented in Verilog.
 
Then the gate level circuit generated is logically optimized to meet the targets or goals set as per the user constraints. The clock frequency target is the number one goal that has to be met by the synthesis operation.

2.6 CONCLUSION:-
In this chapter we have learnet about the HDL , synthesis , simulation , how imp is digital ic design flow , types of modelings and data types, what id verilog HDL and more over its uses and impotance.
________________________________________________________________________________________________________________________________________________________________________________
CHAPTER-3
 INTRODUCTION TO ASIC Design AND FPGA BASED DESIGN APPROACHES
 3.1 INTRODUCTION TO ASIC DESIGN FLOW                                                                    
 3.1.1 EXAMPLES 
3.2 INTRODUCTION TO FPGA DESIGN FLOW                                                                     
3.2.1 EXAMPLES 
3.4 CONCLUSION   

3.1 INTRODUCTION TO ASIC DESIGN FLOW :-  Ghum chuka hai dil abh yeh appke dil ki mohabbaat ki galiun mai mautarma,
                                         ke Ghum chuka hai dil abh yeh appke dil ki mohabaat ki galiun mai ,
                                         appki mohabbat aur haseen dil ki yeh ranggen aur pyar sukoon bhari galiun mai ghumrah hogya hun,
                                         main woh gullab jiska appke bina murjhana lazmi hai,
                                         main wo gullab jiski sar zameen jiski jaad app hai appka dil hai.
                                         
                                         iss dill ko qaid karliyah hai appke naam likhe salakhun mai appne,
                                         appke dil sey abh hamara dil hai issqadar juda hua jise ,
                                         koi Dil ke taar bandhe hain aise Jaise bandhi bediyaan,
                                         ankhon mai dimag mai aur khayal mai app ki maujudgi jise samndar ke kinarey parr raith jo pani sey dur na rehsakta.
                                         
                                         
                                         

\
                                     
                                        
                                    

















                 
                
